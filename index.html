<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Cubie Charge</title>
  <style>
    body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
    canvas { background: #0e0e0e; image-rendering: pixelated; display: block; }
    @font-face { font-family: 'pixel-font'; src: url('fonts/super.ttf') format('truetype'); }
  </style>
</head>
<body>
  <canvas id="game" width="400" height="300"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    function createImg(path) {
      const img = new Image();
      img.src = path;
      return img;
    }

    const cubieSprites = [createImg('sprites/cubie/cubie_0.png'), createImg('sprites/cubie/cubie_1.png')];
    const cubieChargeImg = createImg("sprites/cubie/cubie_charge.png");
    const cubieHitImg = createImg("sprites/cubie/cubie_hurt.png"); 
    const energyImgs = [createImg('sprites/energy/energy_0.png'), createImg('sprites/energy/energy_1.png'), createImg('sprites/energy/energy_2.png')];
    const junkImg1 = createImg("sprites/junk/junk.png"); 
    const junkImg2 = createImg("sprites/junk/junk2.png"); 
    const energyBarSprites = Array.from({ length: 11 }, (_, i) => createImg(`sprites/energy_bar/energy_bar_${i}.png`));

    const backgroundStart = createImg("sprites/backgrounds/start.png");
    const backgroundGameOver = createImg("sprites/backgrounds/gameover.png");
    const bgEarth = createImg("sprites/backgrounds/playing.png");
    const bgMars = createImg("sprites/backgrounds/mars.png");
    const bgNeptune = createImg("sprites/backgrounds/neptune.png");

    const levels = [{ score: 30000, name: "PAST" }, { score: 25000, name: "GOD" }, { score: 20000, name: "Master" }, { score: 17500, name: "Pro" }, { score: 15000, name: "Expert" }, { score: 12500, name: "Skilled" }, { score: 7500, name: "Ameteur" }, { score: 2500, name: "Novice" }, { score: 0, name: "Noob" }];

    const ENERGY_BAR_HEIGHT = 40;
    const MILESTONE_MARS = 7500;
    const MILESTONE_JUNK2 = 10000;
    const MILESTONE_NEPTUNE = 17500;

    let gameState = "start", score = 0, energyLevel = 110, speed = 200, drainRate = 3;
    let gameTimer = 0, rechargeBuffer = 0, cubieFrame = 0, cubieFrameCounter = 0;
    let cubieChargeTimer = 0, cubieHitTimer = 0, notificationText = "", notificationTimer = 0;
    let lastPlanet = "Earth", hasShownControls = false, junkSpawnTimer = 0;
    let cubie, energy, junks = [], lastTime = performance.now();

    const keys = { ArrowUp: false, ArrowDown: false };
    document.addEventListener("keydown", e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; });
    document.addEventListener("keyup", e => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

    function getLevelName(score) {
      for (const level of levels) { if (score >= level.score) return level.name; }
      return "Unknown";
    }

    function initGame() {
      cubie = { x: 20, y: ENERGY_BAR_HEIGHT + 100, w: 74, h: 50 };
      energy = { x: 450, y: ENERGY_BAR_HEIGHT + Math.random() * (200) };
      junks = []; junkSpawnTimer = 0;
      score = 0; energyLevel = 110; speed = 200; drainRate = 3; gameTimer = 0;
      rechargeBuffer = 0; cubieChargeTimer = 0; cubieHitTimer = 0;
      notificationText = ""; notificationTimer = 0; lastPlanet = "Earth";
      gameState = !hasShownControls ? "controls" : "playing";
    }

    function safeDraw(img, x, y, w, h) {
      if (img && img.complete && img.naturalWidth !== 0) { ctx.drawImage(img, x, y, w, h); return true; }
      return false;
    }

    function update(currentTime) {
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1); 
      lastTime = currentTime;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let currentBG = bgEarth, currentPlanet = "Earth", spawnInterval = 7;

      if (gameState === "start") currentBG = backgroundStart;
      else if (gameState === "gameover") currentBG = backgroundGameOver;
      else {
        if (score >= MILESTONE_NEPTUNE) { currentBG = bgNeptune; currentPlanet = "Neptune"; spawnInterval = 2.3; }
        else if (score >= MILESTONE_MARS) { currentBG = bgMars; currentPlanet = "Mars"; spawnInterval = 4; }
      }

      if (!safeDraw(currentBG, 0, 0, canvas.width, canvas.height)) safeDraw(bgEarth, 0, 0, canvas.width, canvas.height);

      if (gameState === "playing") {
        if (currentPlanet !== lastPlanet) { notificationText = "Welcome to " + currentPlanet; notificationTimer = 3.0; lastPlanet = currentPlanet; }
        else if (notificationTimer <= 0) {
          if (score >= MILESTONE_NEPTUNE - 1500 && score < MILESTONE_NEPTUNE) notificationText = "Passing by Neptune...";
          else if (score >= MILESTONE_MARS - 1500 && score < MILESTONE_MARS) notificationText = "Passing by Mars...";
          else notificationText = "";
        }

        if (keys.ArrowUp) cubie.y -= 250 * deltaTime;
        if (keys.ArrowDown) cubie.y += 250 * deltaTime;
        cubie.y = Math.max(ENERGY_BAR_HEIGHT, Math.min(canvas.height - cubie.h, cubie.y));

        cubieFrameCounter += deltaTime;
        if (cubieFrameCounter >= 0.2) { cubieFrame = (cubieFrame + 1) % 2; cubieFrameCounter = 0; }
        
        if (cubieChargeTimer > 0) cubieChargeTimer -= deltaTime;
        if (cubieHitTimer > 0) cubieHitTimer -= deltaTime;
        if (notificationTimer > 0) notificationTimer -= deltaTime;

        // Controlled Junk Spawning
        junkSpawnTimer += deltaTime;
        if (junkSpawnTimer >= spawnInterval) {
          junks.push({ 
            x: canvas.width, 
            y: ENERGY_BAR_HEIGHT + Math.random() * (canvas.height - ENERGY_BAR_HEIGHT - 45), 
            w: 45, h: 45, 
            type: (score >= MILESTONE_JUNK2 && Math.random() > 0.4) ? 2 : 1 
          });
          junkSpawnTimer = 0;
        }

        speed += 5 * deltaTime;
        drainRate = (10 * speed) / 380;
        gameTimer += deltaTime;

        if (rechargeBuffer > 0) rechargeBuffer -= deltaTime;
        else energyLevel -= drainRate * deltaTime;
        if (energyLevel <= 0) gameState = "gameover";

        energy.x -= speed * deltaTime;
        if (energy.x < cubie.x + cubie.w && energy.x + 40 > cubie.x && energy.y + 20 > cubie.y && energy.y < cubie.y + cubie.h) {
          score += Math.floor((50 + 5 * gameTimer) * (energyLevel >= 100 ? 1.5 : 1));
          energyLevel = Math.min(110, energyLevel + 10);
          rechargeBuffer = 0.3; cubieChargeTimer = 0.5;
          energy.x = canvas.width; energy.y = ENERGY_BAR_HEIGHT + Math.random() * (220);
        }
        if (energy.x < -40) { energy.x = canvas.width; energy.y = ENERGY_BAR_HEIGHT + Math.random() * (220); }

        for (let i = junks.length - 1; i >= 0; i--) {
          let j = junks[i];
          j.x -= (speed * 0.6) * deltaTime;
          if (j.x < cubie.x + cubie.w && j.x + j.w > cubie.x && j.y < cubie.y + cubie.h && j.y + j.h > cubie.y) {
            energyLevel -= (j.type === 2) ? 22.5 : 15;
            score = Math.max(0, score - (j.type === 2 ? 400 : 250));
            cubieHitTimer = 0.5;
            junks.splice(i, 1); continue;
          }
          if (j.x < -50) junks.splice(i, 1);
        }

        let cImg = cubieSprites[cubieFrame];
        if (cubieHitTimer > 0) cImg = cubieHitImg;
        else if (cubieChargeTimer > 0) cImg = cubieChargeImg;
        safeDraw(cImg, cubie.x, cubie.y, cubie.w, cubie.h);
        safeDraw(energyImgs[Math.floor(gameTimer * 5) % 3], energy.x, energy.y, 44, 27);
        junks.forEach(j => safeDraw(j.type === 2 ? junkImg2 : junkImg1, j.x, j.y, j.w, j.h));
        
        if (notificationText !== "") {
          ctx.fillStyle = "white"; ctx.font = "20px pixel-font"; ctx.textAlign = "center";
          ctx.fillText(notificationText, canvas.width / 2, 80); ctx.textAlign = "left";
        }
        safeDraw(energyBarSprites[Math.max(0, Math.min(10, Math.floor(energyLevel / 10)))], 20, 8, 240, 24);
        ctx.fillStyle = "white"; ctx.font = "16px pixel-font"; ctx.fillText("Score: " + score, 280, 26);
      } else if (gameState === "start") {
        ctx.fillStyle = "white"; ctx.font = "36px pixel-font"; ctx.fillText("Cubie Charge", 100, 150);
        ctx.fillStyle = "#ffc413"; ctx.font = "24px pixel-font"; ctx.fillText("Click to Start", 126, 180);
      } else if (gameState === "controls") {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white"; ctx.font = "18px pixel-font"; ctx.fillText("Controls: Use ↑ and ↓ to move", 60, 140);
        ctx.fillStyle = "#00ff00"; ctx.fillText("TIP: COLLECT rays!", 60, 170); ctx.fillStyle = "#ff0000"; ctx.fillText("AVOID boulders!", 60, 200);
        ctx.fillStyle = "#ffc413"; ctx.fillText("Click to Play", 140, 260);
      } else if (gameState === "gameover") {
        ctx.fillStyle = "#ff1e1e"; ctx.font = "30px pixel-font"; ctx.fillText("Power Depleted", 110, 130);
        ctx.fillStyle = "white"; ctx.font = "24px pixel-font"; ctx.fillText("Score: " + score, 150, 165);
        ctx.fillStyle = "#ffc413"; ctx.fillText("Rank: " + getLevelName(score), 150, 195);
        ctx.fillStyle = "white"; ctx.fillText("Click to Play Again", 110, 230);
      }
      requestAnimationFrame(update);
    }

    canvas.addEventListener("click", () => {
      if (gameState === "start" || gameState === "gameover") initGame();
      else if (gameState === "controls") { hasShownControls = true; gameState = "playing"; }
    });
    requestAnimationFrame(update);
  </script>
</body>
</html>